// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../lib.dart';
import '../utils/error.dart';
import '../utils/types.dart';
import 'bitcoin_ffi.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'uri.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

class FfiInputPair {
  final InputPair field0;

  const FfiInputPair({
    required this.field0,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FfiInputPair> newInstance(
          {required TxIn txin, required PsbtInput psbtin}) =>
      core.instance.api
          .crateApiReceiveFfiInputPairNew(txin: txin, psbtin: psbtin);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiInputPair &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiMaybeInputsOwned {
  final MaybeInputsOwned field0;

  const FfiMaybeInputsOwned({
    required this.field0,
  });

  ///Check that the Original PSBT has no receiver-owned inputs. Return original-psbt-rejected error or otherwise refuse to sign undesirable inputs.
  /// An attacker could try to spend receiver's own inputs. This check prevents that.
  Future<FfiMaybeInputsSeen> checkInputsNotOwned(
          {required FutureOr<bool> Function(Uint8List) isOwned}) =>
      core.instance.api.crateApiReceiveFfiMaybeInputsOwnedCheckInputsNotOwned(
          that: this, isOwned: isOwned);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiMaybeInputsOwned &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiMaybeInputsSeen {
  final MaybeInputsSeen field0;

  const FfiMaybeInputsSeen({
    required this.field0,
  });

  /// Make sure that the original transaction inputs have never been seen before.
  /// This prevents probing attacks. This prevents reentrant Payjoin, where a sender
  /// proposes a Payjoin PSBT as a new Original PSBT for a new Payjoin.
  Future<FfiOutputsUnknown> checkNoInputsSeenBefore(
          {required FutureOr<bool> Function(OutPoint) isKnown}) =>
      core.instance.api
          .crateApiReceiveFfiMaybeInputsSeenCheckNoInputsSeenBefore(
              that: this, isKnown: isKnown);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiMaybeInputsSeen &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiOutputsUnknown {
  final OutputsUnknown field0;

  const FfiOutputsUnknown({
    required this.field0,
  });

  /// Find which outputs belong to the receiver
  Future<FfiWantsOutputs> identifyReceiverOutputs(
          {required FutureOr<bool> Function(Uint8List) isReceiverOutput}) =>
      core.instance.api.crateApiReceiveFfiOutputsUnknownIdentifyReceiverOutputs(
          that: this, isReceiverOutput: isReceiverOutput);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiOutputsUnknown &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiPayjoinProposal {
  final PayjoinProposal field0;

  const FfiPayjoinProposal({
    required this.field0,
  });

  Future<String> extractV1Req() =>
      core.instance.api.crateApiReceiveFfiPayjoinProposalExtractV1Req(
        that: this,
      );

  Future<(Request, ClientResponse)> extractV2Req() =>
      core.instance.api.crateApiReceiveFfiPayjoinProposalExtractV2Req(
        that: this,
      );

  Future<bool> isOutputSubstitutionDisabled() => core.instance.api
          .crateApiReceiveFfiPayjoinProposalIsOutputSubstitutionDisabled(
        that: this,
      );

  Future<void> processRes(
          {required List<int> res, required ClientResponse ohttpContext}) =>
      core.instance.api.crateApiReceiveFfiPayjoinProposalProcessRes(
          that: this, res: res, ohttpContext: ohttpContext);

  Future<String> psbt() =>
      core.instance.api.crateApiReceiveFfiPayjoinProposalPsbt(
        that: this,
      );

  Future<List<OutPoint>> utxosToBeLocked() =>
      core.instance.api.crateApiReceiveFfiPayjoinProposalUtxosToBeLocked(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiPayjoinProposal &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiProvisionalProposal {
  final ProvisionalProposal field0;

  const FfiProvisionalProposal({
    required this.field0,
  });

  Future<FfiPayjoinProposal> finalizeProposal(
          {required FutureOr<String> Function(String) processPsbt,
          BigInt? minFeeRateSatPerVb,
          required BigInt maxFeeRateSatPerVb}) =>
      core.instance.api.crateApiReceiveFfiProvisionalProposalFinalizeProposal(
          that: this,
          processPsbt: processPsbt,
          minFeeRateSatPerVb: minFeeRateSatPerVb,
          maxFeeRateSatPerVb: maxFeeRateSatPerVb);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiProvisionalProposal &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiReceiver {
  final Receiver field0;

  const FfiReceiver({
    required this.field0,
  });

  /// Creates a new `FfiReceiver` with the provided parameters.
  ///
  /// # Parameters
  /// - `address`: The Bitcoin address for the payjoin session.
  /// - `network`: The network to use for address verification.
  /// - `directory`: The URL of the store-and-forward payjoin directory.
  /// - `ohttp_keys`: The OHTTP keys used for encrypting and decrypting HTTP requests and responses.
  /// - `ohttp_relay`: The URL of the OHTTP relay, used to keep client IP address confidential.
  /// - `expire_after`: The duration in seconds after which the session expires.
  ///
  /// # Returns
  /// A new instance of `FfiReceiver`.
  ///
  /// # References
  /// - [BIP 77: Payjoin Version 2: Serverless Payjoin](https://github.com/bitcoin/bips/pull/1483)
  static Future<FfiReceiver> create(
          {required String address,
          required Network network,
          required FfiUrl directory,
          required FfiOhttpKeys ohttpKeys,
          required FfiUrl ohttpRelay,
          BigInt? expireAfter}) =>
      core.instance.api.crateApiReceiveFfiReceiverCreate(
          address: address,
          network: network,
          directory: directory,
          ohttpKeys: ohttpKeys,
          ohttpRelay: ohttpRelay,
          expireAfter: expireAfter);

  Future<(Request, ClientResponse)> extractReq() =>
      core.instance.api.crateApiReceiveFfiReceiverExtractReq(
        that: this,
      );

  static FfiReceiver fromJson({required String json}) =>
      core.instance.api.crateApiReceiveFfiReceiverFromJson(json: json);

  ///The per-session public key to use as an identifier
  String id() => core.instance.api.crateApiReceiveFfiReceiverId(
        that: this,
      );

  FfiPjUriBuilder pjUriBuilder() =>
      core.instance.api.crateApiReceiveFfiReceiverPjUriBuilder(
        that: this,
      );

  Future<FfiUrl> pjUrl() => core.instance.api.crateApiReceiveFfiReceiverPjUrl(
        that: this,
      );

  Future<FfiUncheckedProposal?> processRes(
          {required List<int> body, required ClientResponse ctx}) =>
      core.instance.api.crateApiReceiveFfiReceiverProcessRes(
          that: this, body: body, ctx: ctx);

  String toJson() => core.instance.api.crateApiReceiveFfiReceiverToJson(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiReceiver &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiUncheckedProposal {
  final UncheckedProposal field0;

  const FfiUncheckedProposal({
    required this.field0,
  });

  /// Call this method if the only way to initiate a Payjoin with this receiver
  /// requires manual intervention, as in most consumer wallets.
  ///
  /// So-called "non-interactive" receivers, like payment processors, that allow arbitrary requests are otherwise vulnerable to probing attacks.
  /// Those receivers call `extract_tx_to_check_broadcast()` and `attest_tested_and_scheduled_broadcast()` after making those checks downstream.
  Future<FfiMaybeInputsOwned> assumeInteractiveReceiver() => core.instance.api
          .crateApiReceiveFfiUncheckedProposalAssumeInteractiveReceiver(
        that: this,
      );

  /// Call after checking that the Original PSBT can be broadcast.
  ///
  /// Receiver MUST check that the Original PSBT from the sender can be broadcast, i.e. testmempoolaccept bitcoind rpc returns { “allowed”: true,.. } for get_transaction_to_check_broadcast() before calling this method.
  ///
  /// Do this check if you generate bitcoin uri to receive Payjoin on sender request without manual human approval, like a payment processor. Such so called “non-interactive” receivers are otherwise vulnerable to probing attacks. If a sender can make requests at will, they can learn which bitcoin the receiver owns at no cost. Broadcasting the Original PSBT after some time in the failure case makes incurs sender cost and prevents probing.
  ///
  /// Call this after checking downstream.
  Future<FfiMaybeInputsOwned> checkBroadcastSuitability(
          {BigInt? minFeeRate,
          required FutureOr<bool> Function(Uint8List) canBroadcast}) =>
      core.instance.api
          .crateApiReceiveFfiUncheckedProposalCheckBroadcastSuitability(
              that: this, minFeeRate: minFeeRate, canBroadcast: canBroadcast);

  ///The Sender’s Original PSBT
  Future<Uint8List> extractTxToScheduleBroadcast() => core.instance.api
          .crateApiReceiveFfiUncheckedProposalExtractTxToScheduleBroadcast(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiUncheckedProposal &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiWantsInputs {
  final WantsInputs field0;

  const FfiWantsInputs({
    required this.field0,
  });

  Future<FfiProvisionalProposal> commitInputs() =>
      core.instance.api.crateApiReceiveFfiWantsInputsCommitInputs(
        that: this,
      );

  Future<FfiWantsInputs> contributeInputs(
          {required List<FfiInputPair> replacementInputs}) =>
      core.instance.api.crateApiReceiveFfiWantsInputsContributeInputs(
          that: this, replacementInputs: replacementInputs);

  Future<FfiInputPair> tryPreservingPrivacy(
          {required List<FfiInputPair> candidateInputs}) =>
      core.instance.api.crateApiReceiveFfiWantsInputsTryPreservingPrivacy(
          that: this, candidateInputs: candidateInputs);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiWantsInputs &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiWantsOutputs {
  final WantsOutputs field0;

  const FfiWantsOutputs({
    required this.field0,
  });

  Future<FfiWantsInputs> commitOutputs() =>
      core.instance.api.crateApiReceiveFfiWantsOutputsCommitOutputs(
        that: this,
      );

  Future<bool> isOutputSubstitutionDisabled() => core.instance.api
          .crateApiReceiveFfiWantsOutputsIsOutputSubstitutionDisabled(
        that: this,
      );

  Future<FfiWantsOutputs> replaceReceiverOutputs(
          {required List<TxOut> replacementOutputs,
          required FfiScript drainScript}) =>
      core.instance.api.crateApiReceiveFfiWantsOutputsReplaceReceiverOutputs(
          that: this,
          replacementOutputs: replacementOutputs,
          drainScript: drainScript);

  Future<FfiWantsOutputs> substituteReceiverScript(
          {required FfiScript outputScript}) =>
      core.instance.api.crateApiReceiveFfiWantsOutputsSubstituteReceiverScript(
          that: this, outputScript: outputScript);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiWantsOutputs &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}
