// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../api.dart';
import '../frb_generated.dart';
import '../lib.dart';
import '../utils/types.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'receive/error.dart';
import 'send/error.dart';
import 'uri.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `load`, `save`

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSenderPersister>>
abstract class DartSenderPersister implements RustOpaqueInterface {
  factory DartSenderPersister(
          {required FutureOr<SenderToken> Function(FfiSender) save,
          required FutureOr<FfiSender> Function(SenderToken) load}) =>
      core.instance.api
          .crateApiSendDartSenderPersisterNew(save: save, load: load);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FfiSender>>
abstract class FfiSender implements RustOpaqueInterface {
  Future<(Request, FfiV1Context)> extractV1();

  Future<(Request, FfiV2PostContext)> extractV2(
      {required FfiUrl ohttpProxyUrl});

  static FfiSender fromJson({required String json}) =>
      core.instance.api.crateApiSendFfiSenderFromJson(json: json);

  SenderToken key();

  static Future<FfiSender> load(
          {required SenderToken token,
          required DartSenderPersister persister}) =>
      core.instance.api
          .crateApiSendFfiSenderLoad(token: token, persister: persister);

  String toJson();
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SenderToken>>
abstract class SenderToken implements RustOpaqueInterface {
  /// Convert the sender token to a byte array
  /// This is most useful when storing the token as a key in a map
  Uint8List toBytes();
}

class FfiNewSender {
  final NewSender field0;

  const FfiNewSender({
    required this.field0,
  });

  Future<SenderToken> persist({required DartSenderPersister persister}) =>
      core.instance.api
          .crateApiSendFfiNewSenderPersist(that: this, persister: persister);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiNewSender &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiSenderBuilder {
  final SenderBuilder field0;

  const FfiSenderBuilder({
    required this.field0,
  });

  Future<FfiSenderBuilder> alwaysDisableOutputSubstitution() =>
      core.instance.api
          .crateApiSendFfiSenderBuilderAlwaysDisableOutputSubstitution(
        that: this,
      );

  Future<FfiNewSender> buildNonIncentivizing({required BigInt minFeeRate}) =>
      core.instance.api.crateApiSendFfiSenderBuilderBuildNonIncentivizing(
          that: this, minFeeRate: minFeeRate);

  Future<FfiNewSender> buildRecommended({required BigInt minFeeRate}) =>
      core.instance.api.crateApiSendFfiSenderBuilderBuildRecommended(
          that: this, minFeeRate: minFeeRate);

  Future<FfiNewSender> buildWithAdditionalFee(
          {required BigInt maxFeeContribution,
          int? changeIndex,
          required BigInt minFeeRate,
          required bool clampFeeContribution}) =>
      core.instance.api.crateApiSendFfiSenderBuilderBuildWithAdditionalFee(
          that: this,
          maxFeeContribution: maxFeeContribution,
          changeIndex: changeIndex,
          minFeeRate: minFeeRate,
          clampFeeContribution: clampFeeContribution);

  static Future<FfiSenderBuilder> fromPsbtAndUri(
          {required String psbtBase64, required FfiPjUri pjUri}) =>
      core.instance.api.crateApiSendFfiSenderBuilderFromPsbtAndUri(
          psbtBase64: psbtBase64, pjUri: pjUri);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiSenderBuilder &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiV1Context {
  final V1Context field0;

  const FfiV1Context({
    required this.field0,
  });

  Future<String> processResponse({required List<int> response}) => core
      .instance.api
      .crateApiSendFfiV1ContextProcessResponse(that: this, response: response);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiV1Context &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiV2GetContext {
  final V2GetContext field0;

  const FfiV2GetContext({
    required this.field0,
  });

  Future<(Request, ClientResponse)> extractReq({required String ohttpRelay}) =>
      core.instance.api.crateApiSendFfiV2GetContextExtractReq(
          that: this, ohttpRelay: ohttpRelay);

  Future<String?> processResponse(
          {required List<int> response, required ClientResponse ohttpCtx}) =>
      core.instance.api.crateApiSendFfiV2GetContextProcessResponse(
          that: this, response: response, ohttpCtx: ohttpCtx);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiV2GetContext &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class FfiV2PostContext {
  final V2PostContext field0;

  const FfiV2PostContext({
    required this.field0,
  });

  Future<FfiV2GetContext> processResponse({required List<int> response}) =>
      core.instance.api.crateApiSendFfiV2PostContextProcessResponse(
          that: this, response: response);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FfiV2PostContext &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}
